// Responses API resource
import type { Http } from '../core/http'
import type { PaginationParams } from '../types/common'
import type {
  ArtifactsListResponse,
  CancelResponseResponse,
  CreateFeedbackRequest,
  CreateFeedbackResponse,
  CreateResponseRequest,
  CreateResponseResponse,
  FeedbackListResponse,
  ResponseListResponse,
  ResponseObject,
} from '../types/responses'
import { LocalFileNotSupportedError } from '../errors'

export class ResponsesResource {
  constructor(private readonly http: Http) {}

  private _validateFileReference(uri: string): void {
    if (uri.startsWith('artifact_'))
      return

    try {
      const parsed = new URL(uri)
      const allowedSchemes = [
        'http',
        'https',
        's3',
        'gs',
        'gcs',
        'file',
        'ftp',
        'ftps',
        'blob',
        'data',
      ]

      if (allowedSchemes.includes(parsed.protocol.replace(':', ''))) {
        if ((parsed.protocol === 'http:' || parsed.protocol === 'https протокол:') && !parsed.hostname)
          throw new LocalFileNotSupportedError(uri)

        return
      }
      else {
        throw new LocalFileNotSupportedError(uri)
      }
    }
    catch (error) {
      if (error instanceof LocalFileNotSupportedError)
        throw error
      // If new URL() fails, it's likely a local path
    }

    // No scheme - check for local file path indicators
    const isLocalPath = uri.startsWith('/')
      || uri.startsWith('./')
      || uri.startsWith('../')
      || /^[a-z]:/i.test(uri) // Windows paths
      || uri.startsWith('\\\\') // Windows UNC paths
      || (uri.split('/').length === 1 && uri.includes('.') && !uri.startsWith('artifact_'))

    if (isLocalPath)
      throw new LocalFileNotSupportedError(uri)
  }

  /**
   * Create a new response request for asynchronous processing
   */
  async create(request: CreateResponseRequest): Promise<CreateResponseResponse> {
    if (request.files) {
      for (const file of request.files)
        this._validateFileReference(file.uri)
    }
    return this.http.post<CreateResponseResponse>('/responses', request)
  }

  /**
   * Get response status and content
   * @param responseId - The response ID
   * @param options - Optional parameters
   * @param options.wait - Wait time in seconds for long-polling
   */
  async get(responseId: string, options?: { wait?: number }): Promise<ResponseObject> {
    return this.http.get<ResponseObject>(`/responses/${responseId}`, { params: options })
  }

  /**
   * List responses with optional filtering
   * @param params - Optional filter parameters
   * @param params.userId - Filter by user ID
   * @param params.status - Filter by response status
   * @param params.startDate - Filter responses created after this date
   * @param params.endDate - Filter responses created before this date
   * @param params.limit - Maximum number of responses to return
   * @param params.offset - Number of responses to skip for pagination
   */
  async list(params?: {
    userId?: string
    status?: 'queued' | 'in_progress' | 'succeeded' | 'failed' | 'cancelled'
    startDate?: string
    endDate?: string
    limit?: number
    offset?: number
  }): Promise<ResponseListResponse> {
    const queryParams: Record<string, any> = {}
    if (params?.userId)
      queryParams.user_id = params.userId
    if (params?.status)
      queryParams.status = params.status
    if (params?.startDate)
      queryParams.start_date = params.startDate
    if (params?.endDate)
      queryParams.end_date = params.endDate
    if (params?.limit)
      queryParams.limit = params.limit
    if (params?.offset)
      queryParams.offset = params.offset

    return this.http.get<ResponseListResponse>('/responses', { params: queryParams })
  }

  /**
   * Cancel a queued or in-progress response
   */
  async cancel(responseId: string): Promise<CancelResponseResponse> {
    return this.http.post<CancelResponseResponse>(`/responses/${responseId}/cancel`)
  }

  /**
   * List artifacts generated by a response
   */
  async listArtifacts(
    responseId: string,
    params?: PaginationParams,
  ): Promise<ArtifactsListResponse> {
    return this.http.get<ArtifactsListResponse>(`/responses/${responseId}/artifacts`, { params })
  }

  /**
   * Submit feedback for an active response
   * @param responseId - The response ID
   * @param request - Feedback request details
   */
  async createFeedback(
    responseId: string,
    request: CreateFeedbackRequest,
  ): Promise<CreateFeedbackResponse> {
    return this.http.post<CreateFeedbackResponse>(`/responses/${responseId}/feedback`, request)
  }

  /**
   * List all feedback for a response (consumed and unconsumed)
   * @param responseId - The response ID
   * @param options - Optional parameters
   * @param options.progressId - Optional progress ID to filter feedback
   */
  async listFeedback(
    responseId: string,
    options?: { progressId?: string },
  ): Promise<FeedbackListResponse> {
    const queryParams: Record<string, any> = {}
    if (options?.progressId)
      queryParams.progress_id = options.progressId

    return this.http.get<FeedbackListResponse>(`/responses/${responseId}/feedback`, { params: queryParams })
  }

  /**
   * Perform a quick people search using the specialized quick_people_search agent
   * @param query - Natural language search query (e.g., "Find engineers at Google in SF")
   * @param options - Optional search parameters
   * @param options.limit - Maximum number of results (1-100, default: 20)
   * @param options.dataSources - Specific data sources to use: ["PDL", "CORESIGNAL", "CRUST_DATA"]
   * @returns Response with structured_response containing:
   *   - candidates: List of person results
   *   - totalFound: Total unique candidates found
   *   - appliedFilters: Extracted search filters
   *   - executionTimeMs: Search duration
   *   - dataSourcesUsed: Which sources were queried
   */
  async quickPeopleSearch(
    query: string,
    options?: {
      limit?: number
      dataSources?: string[]
    },
  ): Promise<CreateResponseResponse> {
    const request: CreateResponseRequest = {
      messages: [{ role: 'user', content: query }],
      specializedAgent: 'quick_people_search',
    }

    if (options) {
      const params: Record<string, any> = {}
      if (options.limit !== undefined)
        params.limit = options.limit
      if (options.dataSources)
        params.dataSources = options.dataSources

      if (Object.keys(params).length > 0)
        request.specializedAgentParams = params
    }

    return this.create(request)
  }
}
